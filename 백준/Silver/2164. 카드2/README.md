# [Silver IV] 카드2 - 2164 

[문제 링크](https://www.acmicpc.net/problem/2164) 

### 성능 요약

메모리: 55920 KB, 시간: 144 ms

### 분류

자료 구조, 큐

### 제출 일자

2025년 1월 13일 23:00:11

### 문제 설명

<p>N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.</p>

<p>이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.</p>

<p>예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.</p>

<p>N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.</p>

### 출력 

 <p>첫째 줄에 남게 되는 카드의 번호를 출력한다.</p>

----

큐를 구현하는 방식에 따라 **popleft()**의 시간 복잡도가 달라질 수 있습니다.

1. collections.deque의 popleft()
	•	collections.deque는 ** 이중 연결 리스트(double-ended queue) **를 기반으로 구현되어 있습니다.
	•	따라서, popleft()는 **O(1)**의 시간 복잡도를 가집니다.
이는 요소를 제거하는 데 연결 리스트의 포인터만 업데이트하면 되기 때문입니다.

2. 리스트(list)의 pop(0)
	•	리스트는 **동적 배열(dynamic array)**을 기반으로 구현되어 있습니다.
	•	리스트에서 pop(0)은 첫 번째 요소를 제거한 뒤, 나머지 요소를 앞으로 이동해야 하므로 **O(n)**의 시간 복잡도를 가집니다.
이동 연산은 리스트의 크기(n)에 비례합니다.

정리

자료구조	연산	시간 복잡도
collections.deque	popleft()	O(1)
리스트(list)	pop(0)	O(n)

왜 deque가 더 효율적인가?
	•	리스트는 동적 배열이므로 연속된 메모리 공간에 데이터를 저장합니다.
따라서, 첫 번째 요소를 제거하면 뒤에 있는 모든 요소를 이동해야 합니다.
	•	deque는 이중 연결 리스트를 사용하므로, popleft()에서 첫 번째 노드의 참조만 제거하면 됩니다.
이동이 필요 없으므로 O(1)로 처리할 수 있습니다.

언제 deque를 사용해야 할까?
	•	데이터의 앞뒤에서 빈번히 삽입/삭제가 이루어지는 경우, deque를 사용하는 것이 효율적입니다.
	•	반대로, 인덱스 접근이나 중간 삽입/삭제가 필요한 경우에는 리스트가 더 적합할 수 있습니다.

